stream API借助于同样新出现的Lambda表达式，极大的提高编程效率和程序可读性。同时，它提供串行和并行两种模式进行汇聚操作，
并发模式能够充分利用多核处理器的优势。通常，编写并行代码很难而且容易出错, 但使用Stream API无需编写一行多线程的代码，就可以很方便地写出高性能的并发程序。

我们可以将流看做流水线，这个流水线是处理数据的流水线，一个产品经过流水线会有一道道的工序就如同对数据的中间操作，比如过滤我不需要的，给数据排序能，
最后的终止操作就是产品从流水线下来，我们就可以统一打包放入仓库了。

Java8新增了Stream、IntStream、DoubleStream等流式API，这些代表支持串行、并行聚集操作的元素。其
中Steam是通用的流接口。每个流式都有Builder，开发者用Builder来创建对应的流：
1. 使用Stream或XxxStream的builder()类方法创建对应的流
2. 重复调用Builder的add()方法向该流中添加多个元素
3. 添加完后，调用Builder的build()方法获取对应的流
4. 调用Stream的聚集方法，分为中间方法和末端方法；

特性：
1、Stream不存储数据，而是按照特定的规则对数据进行计算，一般会输出结果。
2、Stream不会改变数据源，通常情况下会产生一个新的集合或一个值。
3、Stream具有延迟执行特性，只有调用终端操作时，中间操作才会执行。

关于流的方法还有两个状态：
1. 有状态的方法——会给流增加新属性，同时需要更大的性能开销，如元素的最大值，排序处理等。
2. 短路方法——今早结束对流的操作，不必检查所有的元素。

中间方法：允许流保持打开状态，并允许直接调用后续方法，中间方法的返回值是另一个流。
1. filter(Predicate predicate)：过滤Stream中所有不符合predicate的元素
2. mapToXxx(ToXxxFunction mapper)：对流中元素一一进行转换
3. peek(Consumer action)：依次对每个元素执行一些操作
4. distinct()：用于排序流中所有重复的元素。是有状态的方法。
5. sorted()：该方法用于保证流中的元素在后续的访问中处于有序状态。是有状态的方法。
6. limit(long maxSize)：该方法用于保证流中的元素在后续的访问中的最大允许访问的元素个数。是有状态的短路方法。

末端方法：是对流对象的最终操作，某个Stream对象执行末端方法后，该流对象会被“消耗”且不可再用。
1. forEach(Consumer action)：遍历流中所有元素，对每个元素执行action
2. toArray()：将流中所有元素转换成一个数组
3. reduce()：该方法有3个重载的版本，都用于通过某种操作来合并流中的元素
4. min()：返回流中所有元素的最小值
5. max()：返回流中所有元素的最大值
6. count()：返回流中所有元素的数量
7. anyMatch()：判断流中是否至少包含一个元素符合Predicate条件
8. allMatch()：与上大差不差
9. nonMatch()：与上大差不差
10. findFirst()：返回流中第一个元素
11. findAny()：返回流中任意一个元素